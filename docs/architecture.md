# Architecture Overview

This document summarizes the current structure of the jd-rs workspace and how it maps to the upstream Go [`jd`](https://github.com/josephburnett/jd) codebase (tag `v2.2.2`). It reflects the implementation state after the Milestone 8 documentation pass.

## Workspace Layout

- `crates/jd-core` – Core library exposing the canonical data model, diff representation, patch engine, and renderers. This crate mirrors `v2/node.go`, `v2/list.go`, `v2/object.go`, `v2/patch_*.go`, and renderer files from the Go project. Public APIs are documented with runnable rustdoc examples.
- `crates/jd-cli` – Clap-based CLI that wires `jd-core` into a parity-focused command-line experience. Diff mode with native, JSON Patch, and JSON Merge Patch outputs is available; other modes emit parity-checked "not implemented" errors until their milestones land.
- `crates/jd-benches` – Benchmark harness backed by curated fixtures (GitHub issue, Kubernetes deployment, large array). Criterion benchmarks and Go parity scripts consume these datasets.
- `crates/jd-fuzz` – Reusable fuzzing helpers for canonicalization, diff, and patch pipelines. `cargo fuzz` targets wrap the exported functions, ensuring crashes map directly to production code paths.
- `tests/` – Integration tests for CLI behavior (help, version, diff rendering) and golden comparisons against fixtures generated by the Go binary.
- `docs/` – Specifications, implementation plan, milestone status reports, architecture notes, and benchmark methodology.

## Core Library (`jd-core`)

### Data Model

`Node` encodes the canonicalized JSON/YAML structure with deterministic ordering for objects and set/multiset-aware helpers for arrays. `Number` wraps IEEE-754 doubles with precision-aware equality and Go-compatible hashing. `DiffOptions` toggles array semantics, numeric tolerances, and set-key metadata; validation enforces the same constraints as Go `parseMetadata`.

### Diff Engine

`diff::diff_nodes` dispatches based on the `Node` variant. Scalars yield replacement hunks via `diff::primitives`. Objects recurse lexicographically, emitting additions/removals with metadata propagation. Arrays leverage the list-mode implementation backed by deterministic Myers LCS tie-breaking, reproducing Go's `jsonList.diff` cursor mathematics (`diff/list.rs`). Path handling lives in `diff/path.rs` and exposes JSON Pointer-aware helpers used by renderers.

### Patch & Renderers

`patch::apply_patch` applies diffs with strict vs merge strategies inherited from metadata. List patching validates before/after context and handles `-1` append semantics. Object patching materializes merge branches lazily, aligning with Go's `jsonObject.patch`. Renderers convert diffs into native jd text, JSON Patch (RFC 6902), JSON Merge Patch (RFC 7386), or raw JSON for debugging; they re-use the patch engine to guarantee canonical output identical to the Go implementation.

### Hashing & Equality

`hash::{hash_bytes, combine}` implements FNV-1a hashing so that structural equality, diff alignment, and set/multiset comparisons behave identically to Go's `hashCode` utilities. `Node::eq_with_options` and `Node::hash_code` route through these helpers while honoring `DiffOptions`.

## CLI (`jd-cli`)

The CLI uses `clap` to mirror the Go flag surface. Diff mode reads inputs from files or STDIN, canonicalizes JSON/YAML via `jd-core`, computes the diff, and renders it according to `--format`. Exit codes match Go semantics: `0` for no diff, `1` when differences exist, and `1` on error. Unsupported modes (`-p`, `-t`, `--git-diff-driver`, `--port`) currently emit parity-matching error messages pending future milestones.

## Supporting Crates

- `jd-benches` exports `Corpus` and `Dataset` types with lazy fixture loading, diff computation, and rendering helpers shared by Criterion benches and parity scripts.
- `jd-fuzz` exposes lightweight entry points that accept raw byte slices, construct random nodes using `arbitrary`, and stress canonicalization/diff/patch paths. The helpers swallow recoverable errors so fuzzers can continue exploring new inputs.

## Testing & Parity Strategy

- Unit tests live alongside modules (`*_test` sections) covering invariants, path handling, diff edge cases, and patch semantics.
- Integration tests under `tests/` invoke the CLI using `assert_cmd` and compare outputs to golden fixtures generated via the Go binary.
- Property tests use `proptest` (e.g., JSON round-trips, diff idempotence) while fuzz smoke tests call into `jd-fuzz` helpers.
- Golden fixtures reside in `tests/fixtures/`; regeneration scripts under `scripts/` invoke the Go binary to ensure parity.

## Documentation & ADRs

Every public API includes rustdoc with runnable examples (`cargo test --doc`). Repository documentation (README, specs, status updates) stays synchronized with implementation changes. Non-trivial decisions, trade-offs, or divergences from Go behavior are recorded in `ADRs/` and referenced from code or documentation where appropriate.
